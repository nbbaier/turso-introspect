import type { Schema, Table } from './schema';

export function formatJson(schema: Schema): string {
  return JSON.stringify(schema, null, 2);
}

export function formatSql(schema: Schema): string {
  const lines: string[] = [];
  
  lines.push(`-- Schema generated by turso-introspect`);
  lines.push(`-- Database: ${schema.metadata.database}`);
  lines.push(`-- Timestamp: ${schema.metadata.timestamp}`);
  lines.push('');

  // Topological sort for tables
  const sortedTables = sortTablesTopologically(schema.tables);

  // 1. Tables
  for (const table of sortedTables) {
    lines.push(`-- Table: ${table.name}`);
    
    // We prefer the original SQL from sqlite_master if available, as it preserves formatting and comments.
    // However, we might want to strip foreign keys if we want to add them later (as per spec: "Foreign key constraints as separate ALTER TABLE statements").
    // But SQLite doesn't support ADD CONSTRAINT for Foreign Keys easily in all versions, or rather, it's a bit complex.
    // Wait, the spec says: "Foreign key constraints as separate ALTER TABLE statements (enables order-independent execution)".
    // SQLite does NOT support `ALTER TABLE ... ADD CONSTRAINT FOREIGN KEY`.
    // It only supports renaming tables and adding columns.
    // So "Foreign key constraints as separate ALTER TABLE statements" is actually NOT possible in standard SQLite for FKs.
    // UNLESS the spec implies we are generating SQL that *would* be valid if we were re-creating, but maybe they mean `CREATE TABLE` order matters?
    // "Tables sorted in topological order based on foreign key dependencies" -> This is the standard way to handle SQLite.
    // "Foreign key constraints as separate ALTER TABLE statements" -> This is strange for SQLite. 
    // Maybe the spec author is thinking of Postgres/MySQL?
    // OR, maybe they mean using `PRAGMA foreign_keys = OFF;` ?
    
    // Let's re-read the spec carefully.
    // "Foreign key constraints as separate ALTER TABLE statements (enables order-independent execution)"
    // This is strictly NOT supported by SQLite.
    // However, if the target is to run this SQL against a Turso DB, maybe Turso has extensions? Unlikely.
    // OR, maybe the output SQL is meant to be just standard SQLite.
    
    // If I cannot do ALTER TABLE ADD FK, then I MUST rely on topological sort.
    // If I do topological sort, I can just use the `CREATE TABLE` statements as is (with inline FKs).
    
    // The spec mandates: "Tables sorted in topological order".
    // AND "Foreign key constraints as separate ALTER TABLE statements".
    // This is a contradiction for SQLite.
    
    // Attempting to implement "Foreign key constraints as separate ALTER TABLE" for SQLite is impossible.
    // I will assume the topological sort is the primary requirement for correctness.
    // And I will try to output standard CREATE TABLE statements.
    // If I strip FKs from CREATE TABLE and try to add them later, it will fail.
    
    // However, if I stick to "Tables sorted in topological order", that solves the dependency issue for creation.
    // So I will prioritize topological sort and outputting the `sql` field from `sqlite_master`.
    
    lines.push(table.sql + ';');
    lines.push('');
    
    // Indexes
    // sqlite_master table SQL does NOT include external indexes (created with CREATE INDEX).
    // It only includes inline constraints (PRIMARY KEY, UNIQUE).
    // So we iterate over indexes and output the ones that have their own SQL.
    for (const idx of table.indexes) {
      if (idx.origin === 'c' && idx.sql) {
        lines.push(idx.sql + ';');
      }
    }
    lines.push('');
  }

  // 2. Views
  for (const view of schema.views) {
    lines.push(`-- View: ${view.name}`);
    lines.push(view.sql + ';');
    lines.push('');
  }

  // 3. Triggers
  for (const trigger of schema.triggers) {
     lines.push(`-- Trigger: ${trigger.name}`);
     lines.push(trigger.sql + ';');
     lines.push('');
  }

  return lines.join('\n');
}

function sortTablesTopologically(tables: Table[]): Table[] {
  const tableMap = new Map(tables.map(t => [t.name, t]));
  const visited = new Set<string>();
  const visiting = new Set<string>(); // for cycle detection
  const sorted: Table[] = [];

  function visit(tableName: string) {
    if (visited.has(tableName)) return;
    if (visiting.has(tableName)) {
      // Cycle detected. We just break the cycle here and proceed.
      // In a real circular dependency, SQLite allows it if we defer FK checks, but for creation order, we just have to pick one.
      return; 
    }
    
    visiting.add(tableName);
    
    const table = tableMap.get(tableName);
    if (table) {
      for (const fk of table.foreignKeys) {
        // Dependency: 'table' depends on 'fk.table'
        if (fk.table !== tableName && tableMap.has(fk.table)) {
           visit(fk.table);
        }
      }
    }
    
    visiting.delete(tableName);
    visited.add(tableName);
    if (table) sorted.push(table);
  }

  for (const table of tables) {
    visit(table.name);
  }

  return sorted;
}
